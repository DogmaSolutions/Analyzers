<?xml version="1.0" encoding="utf-8"?>
<root>
    <!-- 
      Microsoft ResX Schema 
      
      Version 2.0
      
      The primary goals of this format is to allow a simple XML format 
      that is mostly human readable. The generation and parsing of the 
      various data types are done through the TypeConverter classes 
      associated with the data types.
      
      Example:
      
      ... ado.net/XML headers & schema ...
      <resheader name="resmimetype">text/microsoft-resx</resheader>
      <resheader name="version">2.0</resheader>
      <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
      <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
      <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
      <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
      <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
          <value>[base64 mime encoded serialized .NET Framework object]</value>
      </data>
      <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
          <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
          <comment>This is a comment</comment>
      </data>
                  
      There are any number of "resheader" rows that contain simple 
      name/value pairs.
      
      Each data row contains a name, and value. The row also contains a 
      type or mimetype. Type corresponds to a .NET class that support 
      text/value conversion through the TypeConverter architecture. 
      Classes that don't support this are serialized and stored with the 
      mimetype set.
      
      The mimetype is used for serialized objects, and tells the 
      ResXResourceReader how to depersist the object. This is currently not 
      extensible. For a given mimetype the value must be set accordingly:
      
      Note - application/x-microsoft.net.object.binary.base64 is the format 
      that the ResXResourceWriter will generate, however the reader can 
      read any of the formats listed below.
      
      mimetype: application/x-microsoft.net.object.binary.base64
      value   : The object must be serialized with 
              : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
              : and then encoded with base64 encoding.
      
      mimetype: application/x-microsoft.net.object.soap.base64
      value   : The object must be serialized with 
              : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
              : and then encoded with base64 encoding.
  
      mimetype: application/x-microsoft.net.object.bytearray.base64
      value   : The object must be serialized into a byte array 
              : using a System.ComponentModel.TypeConverter
              : and then encoded with base64 encoding.
      -->
    <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
        <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
        <xsd:element name="root" msdata:IsDataSet="true">
            <xsd:complexType>
                <xsd:choice maxOccurs="unbounded">
                    <xsd:element name="metadata">
                        <xsd:complexType>
                            <xsd:sequence>
                                <xsd:element name="value" type="xsd:string" minOccurs="0" />
                            </xsd:sequence>
                            <xsd:attribute name="name" use="required" type="xsd:string" />
                            <xsd:attribute name="type" type="xsd:string" />
                            <xsd:attribute name="mimetype" type="xsd:string" />
                            <xsd:attribute ref="xml:space" />
                        </xsd:complexType>
                    </xsd:element>
                    <xsd:element name="assembly">
                        <xsd:complexType>
                            <xsd:attribute name="alias" type="xsd:string" />
                            <xsd:attribute name="name" type="xsd:string" />
                        </xsd:complexType>
                    </xsd:element>
                    <xsd:element name="data">
                        <xsd:complexType>
                            <xsd:sequence>
                                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
                            </xsd:sequence>
                            <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
                            <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
                            <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
                            <xsd:attribute ref="xml:space" />
                        </xsd:complexType>
                    </xsd:element>
                    <xsd:element name="resheader">
                        <xsd:complexType>
                            <xsd:sequence>
                                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                            </xsd:sequence>
                            <xsd:attribute name="name" type="xsd:string" use="required" />
                        </xsd:complexType>
                    </xsd:element>
                </xsd:choice>
            </xsd:complexType>
        </xsd:element>
    </xsd:schema>
    <resheader name="resmimetype">
        <value>text/microsoft-resx</value>
    </resheader>
    <resheader name="version">
        <value>2.0</value>
    </resheader>
    <resheader name="reader">
        <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
    </resheader>
    <resheader name="writer">
        <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
    </resheader>
    <data name="DSA001AnalyzerDescription" xml:space="preserve">
    <value>A WebApi method is using Entity Framework DbContext to directly manipulate data through a LINQ query expression.
WebApi controllers should not contain data-manipulation business logics.
Move the data-manipulation business logics into a more appropriate class, or even better, an injected service.</value>
  </data>
    <data name="DSA001AnalyzerMessageFormat" xml:space="preserve">
    <value>The WebApi method '{0}' is using Entity Framework DbContext to directly manipulate data through a LINQ query expression. WebApi controllers should not contain data-manipulation business logics. Move the data-manipulation business logics into a more appropriate class, or even better, an injected service. See https://github.com/DogmaSolutions/Analyzers?tab=readme-ov-file#dsa001</value>
  </data>
    <data name="DSA001AnalyzerTitle" xml:space="preserve">
    <value>WebApi controllers should not contain data-manipulation business logics through a LINQ query expression</value>
  </data>
    <data name="DSA002AnalyzerDescription" xml:space="preserve">
    <value>A WebApi method is using Entity Framework DbSet to directly manipulate data through a LINQ fluent query.
WebApi controllers should not contain data-manipulation business logics.
Move the data-manipulation business logics into a more appropriate class, or even better, an injected service.</value>
  </data>
    <data name="DSA002AnalyzerMessageFormat" xml:space="preserve">
    <value>The WebApi method '{0}' is invoking the method '{1}' of the DbSet '{2}' to directly manipulate data through a LINQ fluent query. WebApi controllers should not contain data-manipulation business logics. Move the data-manipulation business logics into a more appropriate class, or even better, an injected service. See https://github.com/DogmaSolutions/Analyzers?tab=readme-ov-file#dsa002</value>
  </data>
    <data name="DSA002AnalyzerTitle" xml:space="preserve">
    <value>WebApi controllers should not contain data-manipulation business logics through a LINQ fluent query</value>
  </data>
    <data name="DSA003AnalyzerDescription" xml:space="preserve">
    <value>Usually, business logics distinguish between "string with content", and "string NULL or without meaningfull content". Thus, statistically speaking, almost every call to `string.IsNullOrEmpty` could or should be replaced by a call to `string.IsNullOrWhiteSpace`, because in the large majority of cases, a string composed by only spaces, tabs, and return chars is not considered valid because it doesn't have "meaningfull content". In most cases, `string.IsNullOrEmpty` is used by mistake, or has been written when `string.IsNullOrWhiteSpace` was not available. Don't use `string.IsNullOrEmpty`. Use `string.IsNullOrWhiteSpace` instead.</value>
  </data>
    <data name="DSA003AnalyzerMessageFormat" xml:space="preserve">
    <value>Don't use `string.IsNullOrEmpty`. Use `string.IsNullOrWhiteSpace` instead. Usually, business logics distinguish between "string with content", and "string NULL or without meaningfull content". Thus, statistically speaking, almost every call to `string.IsNullOrEmpty` could or should be replaced by a call to `string.IsNullOrWhiteSpace`, because in the large majority of cases, a string composed by only spaces, tabs, and return chars is not considered valid because it doesn't have "meaningfull content". In most cases, `string.IsNullOrEmpty` is used by mistake, or has been written when `string.IsNullOrWhiteSpace` was not available. See https://github.com/DogmaSolutions/Analyzers?tab=readme-ov-file#dsa003</value>
  </data>
    <data name="DSA003AnalyzerTitle" xml:space="preserve">
    <value>Don't use `string.IsNullOrEmpty`. Use `string.IsNullOrWhiteSpace` instead</value>
  </data>
    <data name="DSA004AnalyzerDescription" xml:space="preserve">
    <value>Using `DateTime.Now` into business logics potentially leads to many different problems:
- Incoherence between nodes or processes running in different timezones (even in the same country, i.e. USA, Soviet Union, China, etc)
- Unexpected behaviours in-between legal time changes
- Code conversion problems and loss of timezone info when saving/loading data to/from a datastore

Security-wise, this is correlated to the CWE category “7PK”
https://cwe.mitre.org/data/definitions/361.html
Cit:
*"This category represents one of the phyla in the Seven Pernicious Kingdoms vulnerability classification. It includes weaknesses related to the improper management of time and state in an environment that supports simultaneous or near-simultaneous computation by multiple systems, processes, or threads. According to the authors of the Seven Pernicious Kingdoms, "Distributed computation is about time and state. That is, in order for more than one component to communicate, state must be shared, and all that takes time. Most programmers anthropomorphize their work. They think about one thread of control carrying out the entire program in the same way they would if they had to do the job themselves. Modern computers, however, switch between tasks very quickly, and in multi-core, multi-CPU, or distributed systems, two events may take place at exactly the same time. Defects rush to fill the gap between the programmer's model of how a program executes and what happens in reality. These defects are related to unexpected interactions between threads, processes, time, and information. These interactions happen through shared state: semaphores, variables, the file system, and, basically, anything that can store information."*
</value>
  </data>
    <data name="DSA004AnalyzerMessageFormat" xml:space="preserve">
    <value>In a i18n-compliant system, it's almost never a good idea to use System.DateTime.Now. Please use System.DateTime.UtcNow instead. If you are sure you want to use System.DateTime.Now, use a '#pragma warning disable DSA004 / #pragma warning restore DSA004' directives pair. See https://github.com/DogmaSolutions/Analyzers?tab=readme-ov-file#dsa004</value>
  </data>
    <data name="DSA004AnalyzerTitle" xml:space="preserve">
    <value>Don't use `DateTime.Now`. Use `DateTime.UtcNow` instead</value>
  </data>

    <data name="DSA005AnalyzerDescription" xml:space="preserve">
    <value>An execution flow must always be as deterministic as possible.
This means that all decisions inside a scope or algorithm must be performed on a "stable" and immutable set of parameters/conditions.
When dealing with dates and times, always ensure that the point-in-time reference is fixed, otherwise the algorithm would work on a "sliding window", leading to unpredictable results.
This is particularly impacting in datasource-dependent flows, slow algorithms, and in-between legal time changes.
Security-wise, this is correlated to the CWE category “7PK” (https://cwe.mitre.org/data/definitions/361.html) 
In order to avoid problems, set a `var now = DateTime.UtcNow` variable at the top of the method, or at the beginning of an execution flow/algorithm, and reuse that variable in all places instead of `DateTime.***Now`
</value>
  </data>
    <data name="DSA005AnalyzerMessageFormat" xml:space="preserve">
    <value>Referencing multiple times `DateTime***.Now` or `DateTime***.UtcNow` in the same method, could lead to a non-deterministic point-in-time execution. In order to avoid problems, apply one of these solutions. When measuring elapsed time, use a `StopWatch.StartNew()` combined with `StopWatch.Elapsed`. When NOT measuring elapsed time, set a `var now = DateTime.UtcNow` variable at the top of the method, or at the beginning of an execution flow/algorithm, and reuse that variable in all places instead of `DateTime.***Now`. See https://github.com/DogmaSolutions/Analyzers?tab=readme-ov-file#dsa005        
    </value>
  </data>
    <data name="DSA005AnalyzerTitle" xml:space="preserve">
    <value>Potential non-deterministic point-in-time execution</value>
  </data>


    <data name="DSA006AnalyzerDescription" xml:space="preserve">
    <value>General exceptions should never be thrown, because throwing them, prevents calling methods from discriminating between system-generated exceptions, and application-generated errors.  
This is a bad smell, and could lead to stability and security concerns.  
General exceptions that triggers this rule are: Exception, SystemException, ApplicationException, IndexOutOfRangeException, NullReferenceException, OutOfMemoryException and ExecutionEngineException prevents calling methods from handling true, system-generated exceptions differently than application-generated errors.    
See also MITRE, CWE-397 - Declaration of Throws for Generic Exception (https://cwe.mitre.org/data/definitions/397)
</value>
  </data>
    <data name="DSA006AnalyzerMessageFormat" xml:space="preserve">
    <value>General exceptions should never be thrown, because throwing them, prevents calling methods from discriminating between system-generated exceptions, and application-generated errors. This is a bad smell, and could lead to stability and security concerns. General exceptions that triggers this rule are: Exception, SystemException, ApplicationException, IndexOutOfRangeException, NullReferenceException, OutOfMemoryException and ExecutionEngineException prevents calling methods from handling true, system-generated exceptions differently than application-generated errors  (https://github.com/DogmaSolutions/Analyzers?tab=readme-ov-file#dsa006).        
    </value>
  </data>
    <data name="DSA006AnalyzerTitle" xml:space="preserve">
    <value>General exceptions should not be thrown by user code</value>
  </data>


    <data name="DSA007AnalyzerDescription" xml:space="preserve">
    <value>When initializing a lazy field, use a robust locking pattern, i.e. the "if-lock-if" (aka "double checked locking") to efficiently ensure that the variable is not initialized multiple times, and that no race-conditions occurs.
</value>
  </data>
    <data name="DSA007AnalyzerMessageFormat" xml:space="preserve">
    <value>When initializing a lazy field, use a robust locking pattern, i.e. the "if-lock-if" (aka "double checked locking") to efficiently ensure that the variable is not initialized multiple times, and that no race-conditions occurs (https://github.com/DogmaSolutions/Analyzers?tab=readme-ov-file#dsa007).       
    </value>
  </data>
    <data name="DSA007AnalyzerTitle" xml:space="preserve">
    <value>Use the "if-lock-if" (aka "double checked locking") initialization pattern instead of a simple lock</value>
  </data>

    <data name="DSA008AnalyzerDescription" xml:space="preserve">
    <value>Is a common misunderstanding that the RequiredAttribute is somehow able to validate a not-nullable DateTime property. In reality, not-nullable types are ignored by the RequiredAttribute, so it doesn't make any sense to use it in this context. Remove the RequiredAttribute, or make the property nullable (https://github.com/DogmaSolutions/Analyzers?tab=readme-ov-file#dsa008).
</value>
  </data>
    <data name="DSA008AnalyzerMessageFormat" xml:space="preserve">
    <value>The RequiredAttribute has no impact on a not-nullable DateTime property. Remove the RequiredAttribute, or make the property nullable (https://github.com/DogmaSolutions/Analyzers?tab=readme-ov-file#dsa008).       
    </value>
  </data>
    <data name="DSA008AnalyzerTitle" xml:space="preserve">
    <value>Do not use the RequiredAttribute for a non-nullable DateTime property</value>
  </data>


    <data name="DSA009AnalyzerDescription" xml:space="preserve">
    <value>Is a common misunderstanding that the RequiredAttribute is somehow able to validate a not-nullable DateTimeOffset property. In reality, not-nullable types are ignored by the RequiredAttribute, so it doesn't make any sense to use it in this context. Remove the RequiredAttribute, or make the property nullable (https://github.com/DogmaSolutions/Analyzers?tab=readme-ov-file#dsa009).
</value>
  </data>
    <data name="DSA009AnalyzerMessageFormat" xml:space="preserve">
    <value>The RequiredAttribute has no impact on a not-nullable DateTimeOffset property. Remove the RequiredAttribute, or make the property nullable (https://github.com/DogmaSolutions/Analyzers?tab=readme-ov-file#dsa009).       
    </value>
  </data>
    <data name="DSA009AnalyzerTitle" xml:space="preserve">
    <value>Do not use the RequiredAttribute for a non-nullable DateTimeOffset property</value>
  </data>
</root>